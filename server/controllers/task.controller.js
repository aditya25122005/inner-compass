import asyncHandler from 'express-async-handler';
import Task from '../models/Task.model.js';
import Journal from '../models/journalEntry.model.js';
import User from '../models/user.model.js';
import { generateWellnessTasks } from '../services/taskGenerationService.js';

const getTasks = asyncHandler(async (req, res) => {
    const userId = req.user._id;

    // Get current date at midnight for comparison
    const today = new Date();
    today.setHours(0, 0, 0, 0);

    // Check if user has tasks for today that haven't expired
    let tasks = await Task.find({ 
        user: userId,
        expiresAt: { $gt: new Date() }
    }).sort({ priority: -1, assignedDate: -1 });

    // If no active tasks or less than 4 tasks, generate new ones
    if (tasks.length < 4) {
        console.log(`User has ${tasks.length} tasks. Generating new daily tasks...`);
        
        try {
            // Get user's recent mental health data
            const recentJournals = await Journal.find({ user: userId })
                .sort({ createdAt: -1 })
                .limit(7)
                .select('text mood analysis createdAt');

            const user = await User.findById(userId);
            
            // Calculate task completion rate
            const allUserTasks = await Task.find({ user: userId });
            const completedTasks = allUserTasks.filter(t => t.isCompleted).length;
            const complianceRate = allUserTasks.length > 0 
                ? Math.round((completedTasks / allUserTasks.length) * 100) 
                : 0;

            // Get recent moods
            const recentMoods = recentJournals.map(j => j.mood).filter(Boolean);

            // Calculate mental score
            let mentalScore = user?.mentalHealthScore || 50;
            if (recentJournals.length > 0) {
                const sentiments = recentJournals
                    .map(j => parseFloat(j.analysis?.sentimentScore || 0.5))
                    .filter(s => !isNaN(s));
                if (sentiments.length > 0) {
                    const avg = sentiments.reduce((a, b) => a + b, 0) / sentiments.length;
                    mentalScore = Math.round(avg * 100);
                }
            }

            const userAnalysis = {
                mentalScore,
                latestMood: recentJournals[0]?.mood || 'neutral',
                recentJournals: recentJournals.map(j => ({
                    text: j.text.substring(0, 100),
                    mood: j.mood,
                    sentiment: j.analysis?.sentimentScore
                })),
                complianceRate,
                recentMoods
            };

            // Generate tasks using AI
            const generatedTasks = await generateWellnessTasks(userAnalysis);

            // Delete old expired tasks
            await Task.deleteMany({
                user: userId,
                expiresAt: { $lt: new Date() }
            });

            // Calculate expiration time (24 hours from now)
            const expiresAt = new Date();
            expiresAt.setHours(expiresAt.getHours() + 24);

            // Create new tasks
            const newTasks = generatedTasks.map(task => ({
                user: userId,
                title: task.title,
                description: task.description,
                category: task.category,
                priority: task.priority,
                isCompleted: false,
                isAutoGenerated: true,
                assignedDate: new Date(),
                expiresAt
            }));

            await Task.insertMany(newTasks);
            
            // Fetch updated task list
            tasks = await Task.find({ 
                user: userId,
                expiresAt: { $gt: new Date() }
            }).sort({ priority: -1, assignedDate: -1 });

            console.log(`âœ… Generated ${newTasks.length} personalized tasks for user`);
            
        } catch (error) {
            console.error("Error generating tasks:", error);
            // If generation fails, return existing tasks
        }
    }
    
    res.status(200).json(tasks);
});


const updateTaskStatus = asyncHandler(async (req, res) => {
    const taskId = req.params.id;
    const { isCompleted } = req.body; 
    const userId = req.user._id;

    const task = await Task.findOneAndUpdate(
        { _id: taskId, user: userId },
        { isCompleted },
        { new: true }
    );

    if (!task) {
        res.status(404);
        throw new Error('Task not found or user not authorized.');
    }

    // Update mental health score when task is completed
    if (isCompleted) {
        try {
            const user = await User.findById(userId);
            const currentScore = user.mentalHealthScore || 50;
            
            // Small boost for completing tasks (max +2 per task)
            const newScore = Math.min(100, currentScore + 2);
            
            await User.findByIdAndUpdate(userId, {
                mentalHealthScore: newScore,
                lastScoreUpdate: new Date()
            });

            // Check if all tasks are now completed
            const allUserTasks = await Task.find({ 
                user: userId,
                expiresAt: { $gt: new Date() }
            });
            
            const allCompleted = allUserTasks.length > 0 && allUserTasks.every(t => t.isCompleted);
            
            // If all tasks completed, generate new ones immediately
            if (allCompleted) {
                console.log('ðŸŽ‰ All tasks completed! Generating new personalized tasks...');
                
                // Delete completed tasks
                await Task.deleteMany({ user: userId });
                
                // Get user's mental health data
                const recentJournals = await Journal.find({ user: userId })
                    .sort({ createdAt: -1 })
                    .limit(7)
                    .select('text mood analysis createdAt');

                const completedTasksCount = allUserTasks.filter(t => t.isCompleted).length;
                const complianceRate = allUserTasks.length > 0 
                    ? Math.round((completedTasksCount / allUserTasks.length) * 100) 
                    : 100; // 100% since all completed

                const recentMoods = recentJournals.map(j => j.mood).filter(Boolean);

                let mentalScore = user.mentalHealthScore || 50;
                if (recentJournals.length > 0) {
                    const sentiments = recentJournals
                        .map(j => parseFloat(j.analysis?.sentimentScore || 0.5))
                        .filter(s => !isNaN(s));
                    if (sentiments.length > 0) {
                        const avg = sentiments.reduce((a, b) => a + b, 0) / sentiments.length;
                        mentalScore = Math.round(avg * 100);
                    }
                }

                const userAnalysis = {
                    mentalScore,
                    latestMood: recentJournals[0]?.mood || 'neutral',
                    recentJournals: recentJournals.map(j => ({
                        text: j.text.substring(0, 100),
                        mood: j.mood,
                        sentiment: j.analysis?.sentimentScore
                    })),
                    complianceRate,
                    recentMoods
                };

                // Generate new tasks using AI
                const generatedTasks = await generateWellnessTasks(userAnalysis);

                const expiresAt = new Date();
                expiresAt.setHours(expiresAt.getHours() + 24);

                const newTasks = generatedTasks.map(t => ({
                    user: userId,
                    title: t.title,
                    description: t.description,
                    category: t.category,
                    priority: t.priority,
                    isCompleted: false,
                    isAutoGenerated: true,
                    assignedDate: new Date(),
                    expiresAt
                }));

                await Task.insertMany(newTasks);
                
                console.log(`âœ… Generated ${newTasks.length} new tasks after completion of all previous tasks`);
            }
        } catch (error) {
            console.error('Error updating score on task completion:', error);
        }
    }

    res.status(200).json({
        message: 'Task status updated successfully.',
        task,
    });
});

const regenerateTasks = asyncHandler(async (req, res) => {
    const userId = req.user._id;

    try {
        // Delete all current tasks for user
        await Task.deleteMany({ user: userId });

        // Get user's mental health data
        const recentJournals = await Journal.find({ user: userId })
            .sort({ createdAt: -1 })
            .limit(7)
            .select('text mood analysis createdAt');

        const user = await User.findById(userId);
        
        const allUserTasks = await Task.find({ user: userId });
        const completedTasks = allUserTasks.filter(t => t.isCompleted).length;
        const complianceRate = allUserTasks.length > 0 
            ? Math.round((completedTasks / allUserTasks.length) * 100) 
            : 0;

        const recentMoods = recentJournals.map(j => j.mood).filter(Boolean);

        let mentalScore = user?.mentalHealthScore || 50;
        if (recentJournals.length > 0) {
            const sentiments = recentJournals
                .map(j => parseFloat(j.analysis?.sentimentScore || 0.5))
                .filter(s => !isNaN(s));
            if (sentiments.length > 0) {
                const avg = sentiments.reduce((a, b) => a + b, 0) / sentiments.length;
                mentalScore = Math.round(avg * 100);
            }
        }

        const userAnalysis = {
            mentalScore,
            latestMood: recentJournals[0]?.mood || 'neutral',
            recentJournals: recentJournals.map(j => ({
                text: j.text.substring(0, 100),
                mood: j.mood,
                sentiment: j.analysis?.sentimentScore
            })),
            complianceRate,
            recentMoods
        };

        // Generate new tasks
        const generatedTasks = await generateWellnessTasks(userAnalysis);

        const expiresAt = new Date();
        expiresAt.setHours(expiresAt.getHours() + 24);

        const newTasks = generatedTasks.map(task => ({
            user: userId,
            title: task.title,
            description: task.description,
            category: task.category,
            priority: task.priority,
            isCompleted: false,
            isAutoGenerated: true,
            assignedDate: new Date(),
            expiresAt
        }));

        await Task.insertMany(newTasks);
        
        const tasks = await Task.find({ user: userId }).sort({ priority: -1, assignedDate: -1 });

        res.status(200).json({
            message: 'Tasks regenerated successfully',
            tasks
        });

    } catch (error) {
        console.error('Error regenerating tasks:', error);
        res.status(500).json({ message: 'Failed to regenerate tasks' });
    }
});

export { getTasks, updateTaskStatus, regenerateTasks };
